import { schema, table, t, SenderError } from "spacetimedb/server";
import { handleIntent } from './intent-handler';

// Helper to get current user
function getCurrentUser(ctx: any): any {
    if (!ctx.sender) throw new SenderError('Unauthenticated');

    let user: any = null;
    for (const u of ctx.db.users.id.filter(ctx.sender)) {
        user = u;
        break;
    }

    if (!user) throw new SenderError('User not found');
    return user;
}

export const spacetimedb = schema(
    // Auth users table per Google OAuth -> SpacetimeDB identity flow
    table(
        {
            name: "users", public: true,
        },
        {
            id: t.identity().primaryKey(),
            provider: t.string(),
            provider_sub: t.string(),
            email: t.string().unique(),
            created_at: t.number(),
            online: t.bool()
        }
    ),
    table(
        { name: "characters" },
        {
            id: t.string(),
            owner_id: t.string(),
            name: t.string().unique(),
            class: t.string(),
            stats_json: t.string()
        }
    ),
    table(
        { name: "sessions" },
        {
            account_id: t.identity(),
            device_id: t.string(),
            last_seen: t.number()
        }
    ),
    table(
        { name: "narrative_events", public: true },
        {
            id: t.string(),
            character_id: t.string(),
            text: t.string(),
            intent_json: t.string(),
            timestamp: t.number()
        }
    )
);

function safeStringify(obj: any) {
    return JSON.stringify(
        obj,
        (_key, value) =>
            typeof value === "bigint" ? value.toString() : value,
        2
    );
}

// Application reducers
// ensure_user: inserts or fetches a user based on email
spacetimedb.clientDisconnected(_ctx => {
    const identity = _ctx.sender;
    if (!identity) throw new SenderError('Unauthenticated');

    const user = _ctx.db.users.id.find(identity);
    if (user) {
        user.online = false;
        _ctx.db.users.id.update(user);
    }
});

spacetimedb.clientConnected((ctx) => {
    const jwt = ctx.senderAuth.jwt;

    //throw new SenderError("DEBUG ctx.SenderAuth: " + safeStringify(ctx));

    if (jwt == null) {
        throw new SenderError("Unauthorized: JWT is required to connect");
    }

    const payload = (jwt as any)?.fullPayload ?? {};
    const emailClaim = typeof payload.email === 'string' ? payload.email : undefined;
    const email = emailClaim ?? (jwt.subject ? `${jwt.subject}@placeholder.local` : undefined);

    console.log(`Client connected with sub: ${jwt.subject}, iss: ${jwt.issuer}, email: ${email ?? 'missing'}`);

    if (!email) {
        throw new SenderError('Unauthorized: Email claim is required');
    }

    // Prefer lookup by email; only insert if email doesn't exist
    const user = ctx.db.users.email.find(email);
    if (user) {
        ctx.db.users.id.update({ ...user, online: true });
    }
    else {
        // No existing user for this email; create new bound to current identity
        ctx.db.users.insert({
            id: ctx.sender,
            provider: 'google',
            provider_sub: jwt.subject ?? '',
            email,
            created_at: Date.now(),
            online: true,
        });
    }
});

spacetimedb.reducer('apply_intent', { intent_json: t.string() }, (ctx, { intent_json }) => {
    // Ensure user is authenticated and has valid email
    const user = getCurrentUser(ctx);
    if (!user.email) {
        throw new SenderError('User email not verified');
    }

    let parsed: any = null;
    try {
        parsed = JSON.parse(intent_json);
    } catch (e) {
        console.log('apply_intent: invalid JSON');
        return;
    }
    const result = handleIntent(parsed);
    const event = {
        id: `${Date.now()}`,
        character_id: result.characterId ?? 'unknown',
        text: result.narrativeText,
        intent_json,
        timestamp: Date.now()
    };

    // Use camelCase table accessor generated by SpacetimeDB
    ctx.db.narrativeEvents.insert(event);
    console.log(`apply_intent: ${event.text} by ${user.email}`);
});
