import { schema, table, t, SenderError } from "spacetimedb/server";
import { handleIntent } from './intent-handler';

// Helper to get current user
function getCurrentUser(ctx: any): any {
    if (!ctx.sender) throw new SenderError('Unauthenticated');

    let user: any = null;
    for (const u of ctx.db.users.id.filter(ctx.sender)) {
        user = u;
        break;
    }

    if (!user) throw new SenderError('User not found');
    return user;
}

export const spacetimedb = schema(
    // Auth users table per Google OAuth -> SpacetimeDB identity flow
    table(
        {
            name: "users", public: true,
            indexes: [
                { name: 'byProviderSub', algorithm: 'btree', columns: ['provider_sub'] }
            ]
        },
        {
            id: t.identity().primaryKey(),
            provider: t.string(),
            provider_sub: t.string(),
            email: t.string().unique(),
            created_at: t.number(),
            online: t.bool()
        }
    ),
    table(
        { name: "characters" },
        {
            id: t.string(),
            owner_id: t.string(),
            class: t.string(),
            stats_json: t.string()
        }
    ),
    table(
        { name: "sessions" },
        {
            account_id: t.identity(),
            device_id: t.string(),
            last_seen: t.number()
        }
    ),
    table(
        { name: "narrative_events", public: true },
        {
            id: t.string(),
            character_id: t.string(),
            text: t.string(),
            intent_json: t.string(),
            timestamp: t.number()
        }
    )
);

// lifecycle reducers
spacetimedb.reducer("init", (_ctx) => {
    // Called when the module is initially published
});

// Application reducers
// ensure_user: inserts or fetches a user based on email
spacetimedb.reducer('client_disconnected', (_ctx) => {
    const identity = _ctx.sender;
    if (!identity) throw new SenderError('Unauthenticated');

    const user = _ctx.db.users.id.find(identity);
    if (user) {
        user.online = false;
        _ctx.db.users.id.update(user);
    }
}
);

spacetimedb.clientConnected((ctx) => {
    const jwt = ctx.senderAuth.jwt;

    //throw new SenderError("DEBUG JWT: " + safeStringify(jwt));

    if (jwt == null) {
        throw new SenderError("Unauthorized: JWT is required to connect");
    }

    const payload = (jwt as any)?.fullPayload ?? {};
    const emailClaim = typeof payload.email === 'string' ? payload.email : undefined;
    const email = emailClaim ?? (jwt.subject ? `${jwt.subject}@placeholder.local` : undefined);

    console.log(`Client connected with sub: ${jwt.subject}, iss: ${jwt.issuer}, email: ${email ?? 'missing'}`);

    if (!email) {
        throw new SenderError('Unauthorized: Email claim is required');
    }

    // Prefer lookup by email; only insert if email doesn't exist
    const byEmail = ctx.db.users.email.find(email);
    if (byEmail) {
        byEmail.online = true;
        byEmail.provider = 'google';
        byEmail.provider_sub = jwt.subject ?? byEmail.provider_sub ?? '';
        ctx.db.users.email.update(byEmail);
        return;
    }

    // No existing user for this email; create new bound to current identity
    ctx.db.users.insert({
        id: ctx.sender,
        provider: 'google',
        provider_sub: jwt.subject ?? '',
        email,
        created_at: Date.now(),
        online: true,
    });
    return;
});

// Auth: logout
spacetimedb.reducer('logout', (ctx) => {
    // Event-driven: write a logout marker by inserting a new session heartbeat
    ctx.db.sessions.insert({ account_id: ctx.sender, device_id: 'unknown', last_seen: Date.now() });
    console.log(`logout: ${String(ctx.sender)}`);
});

spacetimedb.reducer('apply_intent', { intent_json: t.string() }, (ctx, { intent_json }) => {
    // Ensure user is authenticated and has valid email
    const user = getCurrentUser(ctx);
    if (!user.email) {
        throw new SenderError('User email not verified');
    }

    let parsed: any = null;
    try {
        parsed = JSON.parse(intent_json);
    } catch (e) {
        console.log('apply_intent: invalid JSON');
        return;
    }
    const result = handleIntent(parsed);
    const event = {
        id: `${Date.now()}`,
        character_id: result.characterId ?? 'unknown',
        text: result.narrativeText,
        intent_json,
        timestamp: Date.now()
    };

    // Use camelCase table accessor generated by SpacetimeDB
    ctx.db.narrative_events.insert(event);
    console.log(`apply_intent: ${event.text} by ${user.email}`);
});

spacetimedb.reducer('tick', (ctx) => {
    // TODO: World tick logic (AI, combat resolution, NPC actions)
    console.log('tick: world updated');
});
